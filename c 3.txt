비트 연산자
And 연산(&) 
OR 연산 (|)
XOR 연산(^)
반전 연산(~)
<<연산(쉬프트 연산)
 >> 연산 - 연산과는 달리 앞부분에 맨 왼쪽에 있었던 수가 채워지게 됨. 예를들어서 11100010 >> 3 = 11111100 이 되고, 00011001 >> 3 = 00000011가 됨(몰랐던 거)

컴퓨터가 음수와 양수를 정하는 방법
4비트라고 가정할 때 0000에서 4번째 부분의 0이 1이면 마이너스(-)이다.
어떤 양의 정수를 음의 정수로 바꾸려고 한다면 비트를 반전 시킨 뒤에 1을 더하면 된다. 왜냐하면, 이런식으로 완성된 수는 부호만 다른 수와 더했을 때
0이 되기 때문이다.=>계산 관련 알고리즘을 크게 안짜도 됨.

0001(정수 1)
1110 1111(정수 -1)

0010(정수 2)
1101 1110(정수 -2)

0011(정수 3)
1100 1101(정수 -3)

0100(정수 4)
1011 1100(정수 -4)

위의 규칙을 참고해보니
양수는 0001이 1인데 음수는 1111이 -1로 시작(이 부분은 양수와의 차이점이라고 볼 수 있음)해서
1110=>-2, 1101=>-3, 1100=>-4 1011=>-5
0이 양수의 숫자가 올라가는 거 처럼(0010=>2, 0011=>3, 0100=>4, 0101=>5)의 규칙을 찾아볼 수 있다. 이 규칙으로도 양수를 음수로 바꿀 때 활용할 수 있겠으나
씹어먹는 c- <4 - 2. 컴퓨터가 음수를 표현하는 방법 (2의 보수)>에서 나온 방법인 0을 1로 1을 0으로 바꾼뒤 그뒤 1을 더하는 방식이 더 빠른 거 같다.